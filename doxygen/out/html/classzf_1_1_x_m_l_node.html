<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>zfcore-demo: zf::XMLNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">zfcore-demo
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>zf</b></li><li class="navelem"><a class="el" href="classzf_1_1_x_m_l_node.html">XMLNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classzf_1_1_x_m_l_node-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">zf::XMLNode Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Узел XML.  
 <a href="classzf_1_1_x_m_l_node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="zf__xml_8h_source.html">zf_xml.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0fa170b37e54af9cea96a44442aae24c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a0fa170b37e54af9cea96a44442aae24c">CloneMode</a> </td></tr>
<tr class="memdesc:a0fa170b37e54af9cea96a44442aae24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Параметры копирования узла  <a href="classzf_1_1_x_m_l_node.html#a0fa170b37e54af9cea96a44442aae24c">More...</a><br /></td></tr>
<tr class="separator:a0fa170b37e54af9cea96a44442aae24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea2736174bd55a6cdf9d1f16f901466c"><td class="memItemLeft" align="right" valign="top">XML_NodeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#aea2736174bd55a6cdf9d1f16f901466c">type</a> () const</td></tr>
<tr class="memdesc:aea2736174bd55a6cdf9d1f16f901466c"><td class="mdescLeft">&#160;</td><td class="mdescRight">type number  <a href="classzf_1_1_x_m_l_node.html#aea2736174bd55a6cdf9d1f16f901466c">More...</a><br /></td></tr>
<tr class="separator:aea2736174bd55a6cdf9d1f16f901466c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954a9b3c14e00a6c1fd5b265213258e2"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a954a9b3c14e00a6c1fd5b265213258e2">name</a> () const</td></tr>
<tr class="memdesc:a954a9b3c14e00a6c1fd5b265213258e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">the name of the node, or the entity  <a href="classzf_1_1_x_m_l_node.html#a954a9b3c14e00a6c1fd5b265213258e2">More...</a><br /></td></tr>
<tr class="separator:a954a9b3c14e00a6c1fd5b265213258e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44366202f35a88eeb92e9c84198aadb8"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a44366202f35a88eeb92e9c84198aadb8">ns</a> () const</td></tr>
<tr class="memdesc:a44366202f35a88eeb92e9c84198aadb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Пространство имен  <a href="classzf_1_1_x_m_l_node.html#a44366202f35a88eeb92e9c84198aadb8">More...</a><br /></td></tr>
<tr class="separator:a44366202f35a88eeb92e9c84198aadb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5040dd817f1f2601edd73175a3e26d"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a2e5040dd817f1f2601edd73175a3e26d">debug</a> () const</td></tr>
<tr class="memdesc:a2e5040dd817f1f2601edd73175a3e26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Выводит содержимое всех дочерних узлов одной строкой  <a href="classzf_1_1_x_m_l_node.html#a2e5040dd817f1f2601edd73175a3e26d">More...</a><br /></td></tr>
<tr class="separator:a2e5040dd817f1f2601edd73175a3e26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47ca9f2bb1339ecbf9d703a99c6ad89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#ab47ca9f2bb1339ecbf9d703a99c6ad89">hasChildren</a> () const</td></tr>
<tr class="memdesc:ab47ca9f2bb1339ecbf9d703a99c6ad89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Есть ли дочерние узлы  <a href="classzf_1_1_x_m_l_node.html#ab47ca9f2bb1339ecbf9d703a99c6ad89">More...</a><br /></td></tr>
<tr class="separator:ab47ca9f2bb1339ecbf9d703a99c6ad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4292c669f2ec4fc1e7cdbb0ff011e9"><td class="memItemLeft" align="right" valign="top">QList&lt; XMLNodePtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a6d4292c669f2ec4fc1e7cdbb0ff011e9">children</a> () const</td></tr>
<tr class="memdesc:a6d4292c669f2ec4fc1e7cdbb0ff011e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Список дочерних узлов.  <a href="classzf_1_1_x_m_l_node.html#a6d4292c669f2ec4fc1e7cdbb0ff011e9">More...</a><br /></td></tr>
<tr class="separator:a6d4292c669f2ec4fc1e7cdbb0ff011e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1394c71cd83d3f5527a5897a5550d8d5"><td class="memItemLeft" align="right" valign="top">XMLNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a1394c71cd83d3f5527a5897a5550d8d5">firstChild</a> () const</td></tr>
<tr class="memdesc:a1394c71cd83d3f5527a5897a5550d8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Первый дочерний узел. Использовать для перебора через next.  <a href="classzf_1_1_x_m_l_node.html#a1394c71cd83d3f5527a5897a5550d8d5">More...</a><br /></td></tr>
<tr class="separator:a1394c71cd83d3f5527a5897a5550d8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e34a0faadc992c1d3106a733d4b732f"><td class="memItemLeft" align="right" valign="top">QList&lt; XMLNodePtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a9e34a0faadc992c1d3106a733d4b732f">allChildren</a> () const</td></tr>
<tr class="memdesc:a9e34a0faadc992c1d3106a733d4b732f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Список всех дочерних узлов (не только прямые потомки)  <a href="classzf_1_1_x_m_l_node.html#a9e34a0faadc992c1d3106a733d4b732f">More...</a><br /></td></tr>
<tr class="separator:a9e34a0faadc992c1d3106a733d4b732f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d45ee1e2bb006fd85795188e1877d0"><td class="memItemLeft" align="right" valign="top">QMap&lt; int, XMLNodePtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#ad7d45ee1e2bb006fd85795188e1877d0">allChildrenMap</a> () const</td></tr>
<tr class="memdesc:ad7d45ee1e2bb006fd85795188e1877d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Список всех дочерних узлов (не только прямые потомки). Каждому узлу присваивается уникальный идентификатор в рамках этого узла. Использовать для маппинга узлов при клонировании  <a href="classzf_1_1_x_m_l_node.html#ad7d45ee1e2bb006fd85795188e1877d0">More...</a><br /></td></tr>
<tr class="separator:ad7d45ee1e2bb006fd85795188e1877d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf51e4366a3cddade9380606ad79175"><td class="memItemLeft" align="right" valign="top">XMLNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#abcf51e4366a3cddade9380606ad79175">findNextContent</a> (const QString &amp;text, zf::CompareOperator op=zf::CompareOperator::Equal, bool stop_at_first_incorrent=false) const</td></tr>
<tr class="memdesc:abcf51e4366a3cddade9380606ad79175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ищет следующий текстовый узел, содержащий указанный текст  <a href="classzf_1_1_x_m_l_node.html#abcf51e4366a3cddade9380606ad79175">More...</a><br /></td></tr>
<tr class="separator:abcf51e4366a3cddade9380606ad79175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dd34ee4f16d111f4eeaf3d81a59450"><td class="memItemLeft" align="right" valign="top">XMLNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a80dd34ee4f16d111f4eeaf3d81a59450">last</a> () const</td></tr>
<tr class="memdesc:a80dd34ee4f16d111f4eeaf3d81a59450"><td class="mdescLeft">&#160;</td><td class="mdescRight">last child link  <a href="classzf_1_1_x_m_l_node.html#a80dd34ee4f16d111f4eeaf3d81a59450">More...</a><br /></td></tr>
<tr class="separator:a80dd34ee4f16d111f4eeaf3d81a59450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd88f59e0bf89e8339c87eaac442e984"><td class="memItemLeft" align="right" valign="top">XMLNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#abd88f59e0bf89e8339c87eaac442e984">parent</a> () const</td></tr>
<tr class="memdesc:abd88f59e0bf89e8339c87eaac442e984"><td class="mdescLeft">&#160;</td><td class="mdescRight">child-&gt;parent link  <a href="classzf_1_1_x_m_l_node.html#abd88f59e0bf89e8339c87eaac442e984">More...</a><br /></td></tr>
<tr class="separator:abd88f59e0bf89e8339c87eaac442e984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa262288c66b2f30f1025ecdbb65e1eb5"><td class="memItemLeft" align="right" valign="top">XMLNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#aa262288c66b2f30f1025ecdbb65e1eb5">next</a> (XML_NodeType <a class="el" href="classzf_1_1_x_m_l_node.html#aea2736174bd55a6cdf9d1f16f901466c">type</a>=XML_NodeType::Undefined) const</td></tr>
<tr class="memdesc:aa262288c66b2f30f1025ecdbb65e1eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">next sibling link <br  />
  <a href="classzf_1_1_x_m_l_node.html#aa262288c66b2f30f1025ecdbb65e1eb5">More...</a><br /></td></tr>
<tr class="separator:aa262288c66b2f30f1025ecdbb65e1eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0606a9ed3939342d999fd0e8570402ad"><td class="memItemLeft" align="right" valign="top">XMLNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a0606a9ed3939342d999fd0e8570402ad">prev</a> (XML_NodeType <a class="el" href="classzf_1_1_x_m_l_node.html#aea2736174bd55a6cdf9d1f16f901466c">type</a>=XML_NodeType::Undefined) const</td></tr>
<tr class="memdesc:a0606a9ed3939342d999fd0e8570402ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">previous sibling link <br  />
  <a href="classzf_1_1_x_m_l_node.html#a0606a9ed3939342d999fd0e8570402ad">More...</a><br /></td></tr>
<tr class="separator:a0606a9ed3939342d999fd0e8570402ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee87cb403736891a7a0b990e7cdc250"><td class="memItemLeft" align="right" valign="top">XMLDocumentPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#afee87cb403736891a7a0b990e7cdc250">doc</a> () const</td></tr>
<tr class="memdesc:afee87cb403736891a7a0b990e7cdc250"><td class="mdescLeft">&#160;</td><td class="mdescRight">the containing document  <a href="classzf_1_1_x_m_l_node.html#afee87cb403736891a7a0b990e7cdc250">More...</a><br /></td></tr>
<tr class="separator:afee87cb403736891a7a0b990e7cdc250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6ecd5475a9fa7a270c5b91bc5b8f75"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a4f6ecd5475a9fa7a270c5b91bc5b8f75">content</a> () const</td></tr>
<tr class="memdesc:a4f6ecd5475a9fa7a270c5b91bc5b8f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">the content  <a href="classzf_1_1_x_m_l_node.html#a4f6ecd5475a9fa7a270c5b91bc5b8f75">More...</a><br /></td></tr>
<tr class="separator:a4f6ecd5475a9fa7a270c5b91bc5b8f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0a51fcae7ad01dc1822a6783fb2b6a"><td class="memItemLeft" align="right" valign="top">QList&lt; XMLAttrPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#afb0a51fcae7ad01dc1822a6783fb2b6a">properties</a> () const</td></tr>
<tr class="memdesc:afb0a51fcae7ad01dc1822a6783fb2b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Список всех свойств.  <a href="classzf_1_1_x_m_l_node.html#afb0a51fcae7ad01dc1822a6783fb2b6a">More...</a><br /></td></tr>
<tr class="separator:afb0a51fcae7ad01dc1822a6783fb2b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef341ec3d43c93947cfec0de1b176df"><td class="memItemLeft" align="right" valign="top">XMLAttrPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a9ef341ec3d43c93947cfec0de1b176df">firstProperty</a> () const</td></tr>
<tr class="memdesc:a9ef341ec3d43c93947cfec0de1b176df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Первое свойство. Использовать для перебора через next.  <a href="classzf_1_1_x_m_l_node.html#a9ef341ec3d43c93947cfec0de1b176df">More...</a><br /></td></tr>
<tr class="separator:a9ef341ec3d43c93947cfec0de1b176df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf9755164dd71a8ae116e49b8b75f6f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a7cf9755164dd71a8ae116e49b8b75f6f">line</a> () const</td></tr>
<tr class="memdesc:a7cf9755164dd71a8ae116e49b8b75f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">line number  <a href="classzf_1_1_x_m_l_node.html#a7cf9755164dd71a8ae116e49b8b75f6f">More...</a><br /></td></tr>
<tr class="separator:a7cf9755164dd71a8ae116e49b8b75f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae89ef3df4f1603067d20939f8689070"><td class="memItemLeft" align="right" valign="top">XMLNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#aae89ef3df4f1603067d20939f8689070">clone</a> (<a class="el" href="classzf_1_1_x_m_l_node.html#a0fa170b37e54af9cea96a44442aae24c">CloneMode</a> mode=CloneProperties) const</td></tr>
<tr class="memdesc:aae89ef3df4f1603067d20939f8689070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Создать копию узла  <a href="classzf_1_1_x_m_l_node.html#aae89ef3df4f1603067d20939f8689070">More...</a><br /></td></tr>
<tr class="separator:aae89ef3df4f1603067d20939f8689070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19f6952b4893e6e6df27bb5922e110c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#ac19f6952b4893e6e6df27bb5922e110c">compare</a> (const QString &amp;<a class="el" href="classzf_1_1_x_m_l_node.html#a4f6ecd5475a9fa7a270c5b91bc5b8f75">content</a>, const QString &amp;<a class="el" href="classzf_1_1_x_m_l_node.html#a44366202f35a88eeb92e9c84198aadb8">ns</a>=QString()) const</td></tr>
<tr class="memdesc:ac19f6952b4893e6e6df27bb5922e110c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сравнить по содержимому и пространству имен (если ns не задано, то оно игнорируемся)  <a href="classzf_1_1_x_m_l_node.html#ac19f6952b4893e6e6df27bb5922e110c">More...</a><br /></td></tr>
<tr class="separator:ac19f6952b4893e6e6df27bb5922e110c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414f1355ae8acbc96b607f4b9f0c7fc8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a414f1355ae8acbc96b607f4b9f0c7fc8">isChildOf</a> (const XMLNodePtr &amp;node) const</td></tr>
<tr class="memdesc:a414f1355ae8acbc96b607f4b9f0c7fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Является ли дочерним узлом для указанного узла  <a href="classzf_1_1_x_m_l_node.html#a414f1355ae8acbc96b607f4b9f0c7fc8">More...</a><br /></td></tr>
<tr class="separator:a414f1355ae8acbc96b607f4b9f0c7fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce1260be0a8b7133d735fbe24dd0356"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a2ce1260be0a8b7133d735fbe24dd0356">isParentOf</a> (const XMLNodePtr &amp;node) const</td></tr>
<tr class="memdesc:a2ce1260be0a8b7133d735fbe24dd0356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Является ли родительским узлом для указанного узла  <a href="classzf_1_1_x_m_l_node.html#a2ce1260be0a8b7133d735fbe24dd0356">More...</a><br /></td></tr>
<tr class="separator:a2ce1260be0a8b7133d735fbe24dd0356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e6badb1c150305b1e7c739f59643af"><td class="memItemLeft" align="right" valign="top">XMLNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a95e6badb1c150305b1e7c739f59643af">parentByName</a> (const QString &amp;<a class="el" href="classzf_1_1_x_m_l_node.html#a954a9b3c14e00a6c1fd5b265213258e2">name</a>, const QString &amp;<a class="el" href="classzf_1_1_x_m_l_node.html#a44366202f35a88eeb92e9c84198aadb8">ns</a>=QString(), const QList&lt; QPair&lt; QString, QString &gt; &gt; &amp;stop_if_found=QList&lt; QPair&lt; QString, QString &gt; &gt;()) const</td></tr>
<tr class="memdesc:a95e6badb1c150305b1e7c739f59643af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти родительский узел по имени  <a href="classzf_1_1_x_m_l_node.html#a95e6badb1c150305b1e7c739f59643af">More...</a><br /></td></tr>
<tr class="separator:a95e6badb1c150305b1e7c739f59643af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46347c43bd33f431d59fc9364d0402a8"><td class="memItemLeft" align="right" valign="top">XMLNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a46347c43bd33f431d59fc9364d0402a8">parentBySameParent</a> (const XMLNodePtr &amp;node) const</td></tr>
<tr class="memdesc:a46347c43bd33f431d59fc9364d0402a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти родительский узел, у которого родитель совпадает с node.  <a href="classzf_1_1_x_m_l_node.html#a46347c43bd33f431d59fc9364d0402a8">More...</a><br /></td></tr>
<tr class="separator:a46347c43bd33f431d59fc9364d0402a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4b0e04cc075b40da20f62fe00efe2e"><td class="memItemLeft" align="right" valign="top">XMLNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a4b4b0e04cc075b40da20f62fe00efe2e">newChild</a> (const QString &amp;<a class="el" href="classzf_1_1_x_m_l_node.html#a954a9b3c14e00a6c1fd5b265213258e2">name</a>, const QString &amp;<a class="el" href="classzf_1_1_x_m_l_node.html#a4f6ecd5475a9fa7a270c5b91bc5b8f75">content</a>)</td></tr>
<tr class="memdesc:a4b4b0e04cc075b40da20f62fe00efe2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation of a new child element, added at the end of this node children list.  <a href="classzf_1_1_x_m_l_node.html#a4b4b0e04cc075b40da20f62fe00efe2e">More...</a><br /></td></tr>
<tr class="separator:a4b4b0e04cc075b40da20f62fe00efe2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2963644058474eb7ad091d87eb6a29e"><td class="memItemLeft" align="right" valign="top">XMLNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#ab2963644058474eb7ad091d87eb6a29e">newTextChild</a> (const QString &amp;<a class="el" href="classzf_1_1_x_m_l_node.html#a954a9b3c14e00a6c1fd5b265213258e2">name</a>, const QString &amp;<a class="el" href="classzf_1_1_x_m_l_node.html#a4f6ecd5475a9fa7a270c5b91bc5b8f75">content</a>)</td></tr>
<tr class="memdesc:ab2963644058474eb7ad091d87eb6a29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation of a new child element, added at the end of this node children list.  <a href="classzf_1_1_x_m_l_node.html#ab2963644058474eb7ad091d87eb6a29e">More...</a><br /></td></tr>
<tr class="separator:ab2963644058474eb7ad091d87eb6a29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15d27f3d9c9d581d4c64dec9fb1d28c"><td class="memItemLeft" align="right" valign="top">XMLNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#ad15d27f3d9c9d581d4c64dec9fb1d28c">addChild</a> (const XMLNodePtr &amp;node)</td></tr>
<tr class="memdesc:ad15d27f3d9c9d581d4c64dec9fb1d28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a list of node at the end of the child list of the parent merging adjacent TEXT nodes Returns: the last child.  <a href="classzf_1_1_x_m_l_node.html#ad15d27f3d9c9d581d4c64dec9fb1d28c">More...</a><br /></td></tr>
<tr class="separator:ad15d27f3d9c9d581d4c64dec9fb1d28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b698f517ff1482b6e38b4a4ff4b10e4"><td class="memItemLeft" align="right" valign="top">XMLNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a9b698f517ff1482b6e38b4a4ff4b10e4">addNextSibling</a> (const XMLNodePtr &amp;elem)</td></tr>
<tr class="memdesc:a9b698f517ff1482b6e38b4a4ff4b10e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new node @elem as the next sibling of this node.  <a href="classzf_1_1_x_m_l_node.html#a9b698f517ff1482b6e38b4a4ff4b10e4">More...</a><br /></td></tr>
<tr class="separator:a9b698f517ff1482b6e38b4a4ff4b10e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9424f0f352515c910d6fae548d6c41"><td class="memItemLeft" align="right" valign="top">XMLNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#add9424f0f352515c910d6fae548d6c41">addPrevSibling</a> (const XMLNodePtr &amp;elem)</td></tr>
<tr class="memdesc:add9424f0f352515c910d6fae548d6c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new node @elem as the previous sibling of this node, merging adjacent TEXT nodes (@elem may be freed) If the new node was already inserted in a document it is first unlinked from its existing context.  <a href="classzf_1_1_x_m_l_node.html#add9424f0f352515c910d6fae548d6c41">More...</a><br /></td></tr>
<tr class="separator:add9424f0f352515c910d6fae548d6c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2137b346a0fe49d382a4445040871ec"><td class="memItemLeft" align="right" valign="top">XMLNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#aa2137b346a0fe49d382a4445040871ec">addSibling</a> (const XMLNodePtr &amp;elem)</td></tr>
<tr class="memdesc:aa2137b346a0fe49d382a4445040871ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new element @elem to the list of siblings of this node, merging adjacent TEXT nodes (@elem may be freed) If the new element was already inserted in a document it is first unlinked from its existing context.  <a href="classzf_1_1_x_m_l_node.html#aa2137b346a0fe49d382a4445040871ec">More...</a><br /></td></tr>
<tr class="separator:aa2137b346a0fe49d382a4445040871ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024d9e54607e58bca7971aa514dece1f"><td class="memItemLeft" align="right" valign="top">XMLAttrPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a024d9e54607e58bca7971aa514dece1f">newProp</a> (const QString &amp;<a class="el" href="classzf_1_1_x_m_l_node.html#a954a9b3c14e00a6c1fd5b265213258e2">name</a>, const QString &amp;value)</td></tr>
<tr class="memdesc:a024d9e54607e58bca7971aa514dece1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new property carried by a node.  <a href="classzf_1_1_x_m_l_node.html#a024d9e54607e58bca7971aa514dece1f">More...</a><br /></td></tr>
<tr class="separator:a024d9e54607e58bca7971aa514dece1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c3cc2fb121f51ea68f1d35eb8d1850"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a77c3cc2fb121f51ea68f1d35eb8d1850">containsProp</a> (const QString &amp;<a class="el" href="classzf_1_1_x_m_l_node.html#a954a9b3c14e00a6c1fd5b265213258e2">name</a>) const</td></tr>
<tr class="memdesc:a77c3cc2fb121f51ea68f1d35eb8d1850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Содержит указанное свойство  <a href="classzf_1_1_x_m_l_node.html#a77c3cc2fb121f51ea68f1d35eb8d1850">More...</a><br /></td></tr>
<tr class="separator:a77c3cc2fb121f51ea68f1d35eb8d1850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064a67b5938c200f47709ed624e647c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a064a67b5938c200f47709ed624e647c3">remove</a> ()</td></tr>
<tr class="memdesc:a064a67b5938c200f47709ed624e647c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удалить узел из дерева и из памяти. После этого содержимое этого объекта станет невалидным  <a href="classzf_1_1_x_m_l_node.html#a064a67b5938c200f47709ed624e647c3">More...</a><br /></td></tr>
<tr class="separator:a064a67b5938c200f47709ed624e647c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bc768c6c5a4ac1203b18833512b5ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a16bc768c6c5a4ac1203b18833512b5ff">unlink</a> ()</td></tr>
<tr class="memdesc:a16bc768c6c5a4ac1203b18833512b5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удалить узел из дерева, но оставить в памяти  <a href="classzf_1_1_x_m_l_node.html#a16bc768c6c5a4ac1203b18833512b5ff">More...</a><br /></td></tr>
<tr class="separator:a16bc768c6c5a4ac1203b18833512b5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b90cfbb4bac14587b5e19de5fec7ce8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a8b90cfbb4bac14587b5e19de5fec7ce8">XMLNode</a> (_xmlNode *node)</td></tr>
<tr class="memdesc:a8b90cfbb4bac14587b5e19de5fec7ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Не использовать  <a href="classzf_1_1_x_m_l_node.html#a8b90cfbb4bac14587b5e19de5fec7ce8">More...</a><br /></td></tr>
<tr class="separator:a8b90cfbb4bac14587b5e19de5fec7ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5d18491b627e6cd5d23815cbdd062eab"><td class="memItemLeft" align="right" valign="top">static QMap&lt; QString, XMLNodePtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a5d18491b627e6cd5d23815cbdd062eab">createNodesMap</a> (const QList&lt; XMLNodePtr &gt; &amp;nodes)</td></tr>
<tr class="memdesc:a5d18491b627e6cd5d23815cbdd062eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Создать уникальный идентификатор для набора узлов. Включает список всех дочерних узлов для всего списка. Использовать для маппинга узлов при клонировании  <a href="classzf_1_1_x_m_l_node.html#a5d18491b627e6cd5d23815cbdd062eab">More...</a><br /></td></tr>
<tr class="separator:a5d18491b627e6cd5d23815cbdd062eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0458b1a6f765c867292309160ea244c5"><td class="memItemLeft" align="right" valign="top">static XMLNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a0458b1a6f765c867292309160ea244c5">newNode</a> (const QString &amp;<a class="el" href="classzf_1_1_x_m_l_node.html#a954a9b3c14e00a6c1fd5b265213258e2">name</a>)</td></tr>
<tr class="memdesc:a0458b1a6f765c867292309160ea244c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation of a new node element.  <a href="classzf_1_1_x_m_l_node.html#a0458b1a6f765c867292309160ea244c5">More...</a><br /></td></tr>
<tr class="separator:a0458b1a6f765c867292309160ea244c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a99433388db2aedeaf2fa98bfd8d313"><td class="memItemLeft" align="right" valign="top">static XMLNodePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzf_1_1_x_m_l_node.html#a4a99433388db2aedeaf2fa98bfd8d313">newText</a> (const QString &amp;<a class="el" href="classzf_1_1_x_m_l_node.html#a4f6ecd5475a9fa7a270c5b91bc5b8f75">content</a>)</td></tr>
<tr class="memdesc:a4a99433388db2aedeaf2fa98bfd8d313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation of a new text node.  <a href="classzf_1_1_x_m_l_node.html#a4a99433388db2aedeaf2fa98bfd8d313">More...</a><br /></td></tr>
<tr class="separator:a4a99433388db2aedeaf2fa98bfd8d313"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Узел XML. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a0fa170b37e54af9cea96a44442aae24c" name="a0fa170b37e54af9cea96a44442aae24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa170b37e54af9cea96a44442aae24c">&#9670;&nbsp;</a></span>CloneMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classzf_1_1_x_m_l_node.html#a0fa170b37e54af9cea96a44442aae24c">zf::XMLNode::CloneMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Параметры копирования узла </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8b90cfbb4bac14587b5e19de5fec7ce8" name="a8b90cfbb4bac14587b5e19de5fec7ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b90cfbb4bac14587b5e19de5fec7ce8">&#9670;&nbsp;</a></span>XMLNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">zf::XMLNode::XMLNode </td>
          <td>(</td>
          <td class="paramtype">_xmlNode *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Не использовать </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad15d27f3d9c9d581d4c64dec9fb1d28c" name="ad15d27f3d9c9d581d4c64dec9fb1d28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15d27f3d9c9d581d4c64dec9fb1d28c">&#9670;&nbsp;</a></span>addChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNodePtr zf::XMLNode::addChild </td>
          <td>(</td>
          <td class="paramtype">const XMLNodePtr &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a list of node at the end of the child list of the parent merging adjacent TEXT nodes Returns: the last child. </p>

</div>
</div>
<a id="a9b698f517ff1482b6e38b4a4ff4b10e4" name="a9b698f517ff1482b6e38b4a4ff4b10e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b698f517ff1482b6e38b4a4ff4b10e4">&#9670;&nbsp;</a></span>addNextSibling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNodePtr zf::XMLNode::addNextSibling </td>
          <td>(</td>
          <td class="paramtype">const XMLNodePtr &amp;&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new node @elem as the next sibling of this node. </p>
<p >If the new node was already inserted in a document it is first unlinked from its existing context. As a result of text merging @elem may be freed. If the new node is ATTRIBUTE, it is added into properties instead of children. If there is an attribute with equal name, it is first destroyed. </p>

</div>
</div>
<a id="add9424f0f352515c910d6fae548d6c41" name="add9424f0f352515c910d6fae548d6c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add9424f0f352515c910d6fae548d6c41">&#9670;&nbsp;</a></span>addPrevSibling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNodePtr zf::XMLNode::addPrevSibling </td>
          <td>(</td>
          <td class="paramtype">const XMLNodePtr &amp;&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new node @elem as the previous sibling of this node, merging adjacent TEXT nodes (@elem may be freed) If the new node was already inserted in a document it is first unlinked from its existing context. </p>
<p >If the new node is ATTRIBUTE, it is added into properties instead of children. If there is an attribute with equal name, it is first destroyed. </p>

</div>
</div>
<a id="aa2137b346a0fe49d382a4445040871ec" name="aa2137b346a0fe49d382a4445040871ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2137b346a0fe49d382a4445040871ec">&#9670;&nbsp;</a></span>addSibling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNodePtr zf::XMLNode::addSibling </td>
          <td>(</td>
          <td class="paramtype">const XMLNodePtr &amp;&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new element @elem to the list of siblings of this node, merging adjacent TEXT nodes (@elem may be freed) If the new element was already inserted in a document it is first unlinked from its existing context. </p>

</div>
</div>
<a id="a9e34a0faadc992c1d3106a733d4b732f" name="a9e34a0faadc992c1d3106a733d4b732f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e34a0faadc992c1d3106a733d4b732f">&#9670;&nbsp;</a></span>allChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; XMLNodePtr &gt; zf::XMLNode::allChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Список всех дочерних узлов (не только прямые потомки) </p>

</div>
</div>
<a id="ad7d45ee1e2bb006fd85795188e1877d0" name="ad7d45ee1e2bb006fd85795188e1877d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d45ee1e2bb006fd85795188e1877d0">&#9670;&nbsp;</a></span>allChildrenMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QMap&lt; int, XMLNodePtr &gt; zf::XMLNode::allChildrenMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Список всех дочерних узлов (не только прямые потомки). Каждому узлу присваивается уникальный идентификатор в рамках этого узла. Использовать для маппинга узлов при клонировании </p>

</div>
</div>
<a id="a6d4292c669f2ec4fc1e7cdbb0ff011e9" name="a6d4292c669f2ec4fc1e7cdbb0ff011e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4292c669f2ec4fc1e7cdbb0ff011e9">&#9670;&nbsp;</a></span>children()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; XMLNodePtr &gt; zf::XMLNode::children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Список дочерних узлов. </p>
<p >Формируется динамически, путем перебора через next </p>

</div>
</div>
<a id="aae89ef3df4f1603067d20939f8689070" name="aae89ef3df4f1603067d20939f8689070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae89ef3df4f1603067d20939f8689070">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNodePtr zf::XMLNode::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classzf_1_1_x_m_l_node.html#a0fa170b37e54af9cea96a44442aae24c">CloneMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>CloneProperties</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Создать копию узла </p>

</div>
</div>
<a id="ac19f6952b4893e6e6df27bb5922e110c" name="ac19f6952b4893e6e6df27bb5922e110c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19f6952b4893e6e6df27bb5922e110c">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool zf::XMLNode::compare </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>ns</em> = <code>QString()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Сравнить по содержимому и пространству имен (если ns не задано, то оно игнорируемся) </p>

</div>
</div>
<a id="a77c3cc2fb121f51ea68f1d35eb8d1850" name="a77c3cc2fb121f51ea68f1d35eb8d1850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c3cc2fb121f51ea68f1d35eb8d1850">&#9670;&nbsp;</a></span>containsProp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool zf::XMLNode::containsProp </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Содержит указанное свойство </p>

</div>
</div>
<a id="a4f6ecd5475a9fa7a270c5b91bc5b8f75" name="a4f6ecd5475a9fa7a270c5b91bc5b8f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6ecd5475a9fa7a270c5b91bc5b8f75">&#9670;&nbsp;</a></span>content()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString zf::XMLNode::content </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the content </p>

</div>
</div>
<a id="a5d18491b627e6cd5d23815cbdd062eab" name="a5d18491b627e6cd5d23815cbdd062eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d18491b627e6cd5d23815cbdd062eab">&#9670;&nbsp;</a></span>createNodesMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QMap&lt; QString, XMLNodePtr &gt; zf::XMLNode::createNodesMap </td>
          <td>(</td>
          <td class="paramtype">const QList&lt; XMLNodePtr &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Создать уникальный идентификатор для набора узлов. Включает список всех дочерних узлов для всего списка. Использовать для маппинга узлов при клонировании </p>

</div>
</div>
<a id="a2e5040dd817f1f2601edd73175a3e26d" name="a2e5040dd817f1f2601edd73175a3e26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5040dd817f1f2601edd73175a3e26d">&#9670;&nbsp;</a></span>debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString zf::XMLNode::debug </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Выводит содержимое всех дочерних узлов одной строкой </p>

</div>
</div>
<a id="afee87cb403736891a7a0b990e7cdc250" name="afee87cb403736891a7a0b990e7cdc250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee87cb403736891a7a0b990e7cdc250">&#9670;&nbsp;</a></span>doc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLDocumentPtr zf::XMLNode::doc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the containing document </p>

</div>
</div>
<a id="abcf51e4366a3cddade9380606ad79175" name="abcf51e4366a3cddade9380606ad79175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf51e4366a3cddade9380606ad79175">&#9670;&nbsp;</a></span>findNextContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNodePtr zf::XMLNode::findNextContent </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">zf::CompareOperator&#160;</td>
          <td class="paramname"><em>op</em> = <code>zf::CompareOperator::Equal</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stop_at_first_incorrent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ищет следующий текстовый узел, содержащий указанный текст </p>

</div>
</div>
<a id="a1394c71cd83d3f5527a5897a5550d8d5" name="a1394c71cd83d3f5527a5897a5550d8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1394c71cd83d3f5527a5897a5550d8d5">&#9670;&nbsp;</a></span>firstChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNodePtr zf::XMLNode::firstChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Первый дочерний узел. Использовать для перебора через next. </p>

</div>
</div>
<a id="a9ef341ec3d43c93947cfec0de1b176df" name="a9ef341ec3d43c93947cfec0de1b176df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef341ec3d43c93947cfec0de1b176df">&#9670;&nbsp;</a></span>firstProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLAttrPtr zf::XMLNode::firstProperty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Первое свойство. Использовать для перебора через next. </p>

</div>
</div>
<a id="ab47ca9f2bb1339ecbf9d703a99c6ad89" name="ab47ca9f2bb1339ecbf9d703a99c6ad89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47ca9f2bb1339ecbf9d703a99c6ad89">&#9670;&nbsp;</a></span>hasChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool zf::XMLNode::hasChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Есть ли дочерние узлы </p>

</div>
</div>
<a id="a414f1355ae8acbc96b607f4b9f0c7fc8" name="a414f1355ae8acbc96b607f4b9f0c7fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a414f1355ae8acbc96b607f4b9f0c7fc8">&#9670;&nbsp;</a></span>isChildOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool zf::XMLNode::isChildOf </td>
          <td>(</td>
          <td class="paramtype">const XMLNodePtr &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Является ли дочерним узлом для указанного узла </p>

</div>
</div>
<a id="a2ce1260be0a8b7133d735fbe24dd0356" name="a2ce1260be0a8b7133d735fbe24dd0356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce1260be0a8b7133d735fbe24dd0356">&#9670;&nbsp;</a></span>isParentOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool zf::XMLNode::isParentOf </td>
          <td>(</td>
          <td class="paramtype">const XMLNodePtr &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Является ли родительским узлом для указанного узла </p>

</div>
</div>
<a id="a80dd34ee4f16d111f4eeaf3d81a59450" name="a80dd34ee4f16d111f4eeaf3d81a59450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dd34ee4f16d111f4eeaf3d81a59450">&#9670;&nbsp;</a></span>last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNodePtr zf::XMLNode::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>last child link </p>

</div>
</div>
<a id="a7cf9755164dd71a8ae116e49b8b75f6f" name="a7cf9755164dd71a8ae116e49b8b75f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf9755164dd71a8ae116e49b8b75f6f">&#9670;&nbsp;</a></span>line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zf::XMLNode::line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>line number </p>

</div>
</div>
<a id="a954a9b3c14e00a6c1fd5b265213258e2" name="a954a9b3c14e00a6c1fd5b265213258e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954a9b3c14e00a6c1fd5b265213258e2">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString zf::XMLNode::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the name of the node, or the entity </p>

</div>
</div>
<a id="a4b4b0e04cc075b40da20f62fe00efe2e" name="a4b4b0e04cc075b40da20f62fe00efe2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4b0e04cc075b40da20f62fe00efe2e">&#9670;&nbsp;</a></span>newChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNodePtr zf::XMLNode::newChild </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation of a new child element, added at the end of this node children list. </p>
<p >If @content is non NULL, a child list containing the TEXTs and ENTITY_REFs node will be created. NOTE: @content is supposed to be a piece of XML CDATA, so it allows entity references. XML special chars must be escaped first, or <a class="el" href="classzf_1_1_x_m_l_node.html#ab2963644058474eb7ad091d87eb6a29e" title="Creation of a new child element, added at the end of this node children list.">newTextChild()</a> should be used. </p>

</div>
</div>
<a id="a0458b1a6f765c867292309160ea244c5" name="a0458b1a6f765c867292309160ea244c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0458b1a6f765c867292309160ea244c5">&#9670;&nbsp;</a></span>newNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XMLNodePtr zf::XMLNode::newNode </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creation of a new node element. </p>

</div>
</div>
<a id="a024d9e54607e58bca7971aa514dece1f" name="a024d9e54607e58bca7971aa514dece1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024d9e54607e58bca7971aa514dece1f">&#9670;&nbsp;</a></span>newProp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLAttrPtr zf::XMLNode::newProp </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new property carried by a node. </p>

</div>
</div>
<a id="a4a99433388db2aedeaf2fa98bfd8d313" name="a4a99433388db2aedeaf2fa98bfd8d313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a99433388db2aedeaf2fa98bfd8d313">&#9670;&nbsp;</a></span>newText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XMLNodePtr zf::XMLNode::newText </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>content</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creation of a new text node. </p>

</div>
</div>
<a id="ab2963644058474eb7ad091d87eb6a29e" name="ab2963644058474eb7ad091d87eb6a29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2963644058474eb7ad091d87eb6a29e">&#9670;&nbsp;</a></span>newTextChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNodePtr zf::XMLNode::newTextChild </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation of a new child element, added at the end of this node children list. </p>
<p >If @content is non NULL, a child TEXT node will be created containing the string @content. NOTE: Use <a class="el" href="classzf_1_1_x_m_l_node.html#a4b4b0e04cc075b40da20f62fe00efe2e" title="Creation of a new child element, added at the end of this node children list.">newChild()</a> if @content will contain entities that need to be preserved. Use this function, if you need to ensure that reserved XML chars that might appear in @content, such as the ampersand, greater-than or less-than signs, are automatically replaced by their XML escaped entity representations. </p>

</div>
</div>
<a id="aa262288c66b2f30f1025ecdbb65e1eb5" name="aa262288c66b2f30f1025ecdbb65e1eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa262288c66b2f30f1025ecdbb65e1eb5">&#9670;&nbsp;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNodePtr zf::XMLNode::next </td>
          <td>(</td>
          <td class="paramtype">XML_NodeType&#160;</td>
          <td class="paramname"><em>type</em> = <code>XML_NodeType::Undefined</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>next sibling link <br  />
 </p>

</div>
</div>
<a id="a44366202f35a88eeb92e9c84198aadb8" name="a44366202f35a88eeb92e9c84198aadb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44366202f35a88eeb92e9c84198aadb8">&#9670;&nbsp;</a></span>ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString zf::XMLNode::ns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Пространство имен </p>

</div>
</div>
<a id="abd88f59e0bf89e8339c87eaac442e984" name="abd88f59e0bf89e8339c87eaac442e984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd88f59e0bf89e8339c87eaac442e984">&#9670;&nbsp;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNodePtr zf::XMLNode::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>child-&gt;parent link </p>

</div>
</div>
<a id="a95e6badb1c150305b1e7c739f59643af" name="a95e6badb1c150305b1e7c739f59643af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e6badb1c150305b1e7c739f59643af">&#9670;&nbsp;</a></span>parentByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNodePtr zf::XMLNode::parentByName </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>ns</em> = <code>QString()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QList&lt; QPair&lt; QString, QString &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>stop_if_found</em> = <code>QList&lt;QPair&lt;QString,&#160;QString&gt;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Найти родительский узел по имени </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Пространство имен </td></tr>
    <tr><td class="paramname">stop_if_found</td><td>Пары [пространство имен,имя узла] при нахождении которых поиск надо прекратить Пространство имен можно задать пустым, тогда оно будет игнорироваться </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46347c43bd33f431d59fc9364d0402a8" name="a46347c43bd33f431d59fc9364d0402a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46347c43bd33f431d59fc9364d0402a8">&#9670;&nbsp;</a></span>parentBySameParent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNodePtr zf::XMLNode::parentBySameParent </td>
          <td>(</td>
          <td class="paramtype">const XMLNodePtr &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Найти родительский узел, у которого родитель совпадает с node. </p>

</div>
</div>
<a id="a0606a9ed3939342d999fd0e8570402ad" name="a0606a9ed3939342d999fd0e8570402ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0606a9ed3939342d999fd0e8570402ad">&#9670;&nbsp;</a></span>prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNodePtr zf::XMLNode::prev </td>
          <td>(</td>
          <td class="paramtype">XML_NodeType&#160;</td>
          <td class="paramname"><em>type</em> = <code>XML_NodeType::Undefined</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>previous sibling link <br  />
 </p>

</div>
</div>
<a id="afb0a51fcae7ad01dc1822a6783fb2b6a" name="afb0a51fcae7ad01dc1822a6783fb2b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0a51fcae7ad01dc1822a6783fb2b6a">&#9670;&nbsp;</a></span>properties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; XMLAttrPtr &gt; zf::XMLNode::properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Список всех свойств. </p>
<p >Формируется динамически, путем перебора через next </p>

</div>
</div>
<a id="a064a67b5938c200f47709ed624e647c3" name="a064a67b5938c200f47709ed624e647c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064a67b5938c200f47709ed624e647c3">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zf::XMLNode::remove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Удалить узел из дерева и из памяти. После этого содержимое этого объекта станет невалидным </p>

</div>
</div>
<a id="aea2736174bd55a6cdf9d1f16f901466c" name="aea2736174bd55a6cdf9d1f16f901466c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2736174bd55a6cdf9d1f16f901466c">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XML_NodeType zf::XMLNode::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type number </p>

</div>
</div>
<a id="a16bc768c6c5a4ac1203b18833512b5ff" name="a16bc768c6c5a4ac1203b18833512b5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bc768c6c5a4ac1203b18833512b5ff">&#9670;&nbsp;</a></span>unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zf::XMLNode::unlink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Удалить узел из дерева, но оставить в памяти </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/we/dev/github/zfcore-demo/reporting/<a class="el" href="zf__xml_8h_source.html">zf_xml.h</a></li>
<li>/home/we/dev/github/zfcore-demo/reporting/zf_xml.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
